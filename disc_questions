Part 1: Discussion Questions

Recursion

1.  In your own words, what is Recursion?
    When a function calls itself
2.  Why is it necessary to have a Base Case?
    To tell the function when to stop recursive calls.. It prevents an infinte loop (if properly constructed)   

Graphs
1.  What is a Graph?    
    Graphs have nodes, like trees and linked lists, but the nodes are not heirarchical, they instead show relationships between nodes. An edge or line between nodes sets up a bi-directional or one-directional relationship between nodes. Nodes that connected are called "adjacent."
2.  How is a Graph different from a Tree? 
    Graphs are not necessarily heirarchical, and when they do describe a directional relationship, a node can have more than one parent.
3.  Give an example of somthing that would be good to model with a Graph.
    A process where nodes have dependencies, facebook or linkedin connections

Performance of Different Data Structures

Fill in the missing spots in the chart with the correct runtimes. Do this by reasoning through how the data structures work, NOT by looking up the solution. Add-R means add to the right/end/top and Add-L means add to the left/beginning. There are Xs in the spots where that operation doesn’t make sense for that data structure (for instance, you can’t index a Stack, or pop from the end of a Queue). We’ve provided the first few answers for you.

Fill in the runtimes for the following actions for the table below:

Data Structure                  Index   Search  Add-R   Add-L   Pop-L   Pop-R
Python List (Array)             O(1)    O(n)    O(1)    O(n)    O(n)    O(1)
Linked list                     O(n)    O(n)    O(1)    O(1)    O(1)    O(n)
Doubly-Linked List              O(n)    O(n)    O(1)    O(1)    O(1)    O(1)
Queue (as Array)                X       X       O(1)    X       O(n)    X
Queue (as LL or DLL)            X       X       O(1)    X       O(1)    X
Stack (as Array, LL, or DLL)    X       X       O(1)    X       X       O(1)
Deque (as DLL)                  X       X       O(1)    O(1)    O(1)    O(1)

    Index: Find an item in the structure when you know its position
    Search: Find an item in the structure when you know its data
    Add(R/L): Set a key in set/dictionary or add node to tree
    Pop(R/L): Remove a key or node

Fill in Runtime and Memory:

The answers for Dictionary have been provided; you should fill in the rest:

Data Structure          Get     Add     Delete  Iterate Memory
Dictionary (Hash Map)   O(1)    O(1)    O(1)    O(n)    medium
Set (Hash Map)          O(1)    O(1)    O(1)    O(n)    medium
Binary Search tree      O(logn) O(n)    O(n)    O(1)    low
Tree                    O(n)    O(1)    O(1)    O(1)    low

    Get: Find an item in the structure
    Add: Set a key in set/dictionary or add node to tree
    Delete: Remove a key or node
    Iterate: Find next item in data structure
    Memory: Relative to data, how much memory is used? (Choices: a little, medium, or a lot)

Sorting

1.  Describe in words how the Bubble Sort algorithm works.
    It iterates through a list with nested for loops and swaps from R-L higher items to the R until all items to the R are higher. 

2.  Describe in words how the Merge Sort algorithm works.
    It breaks down lists into a list of one element, then it can compare 2 pre-sorted (one element) lists and make a new list with those elements in order. 

3.  Describe in words how the Quick Sort algorithm works.
    You pick a pivot point (ideally near the center of what you are sorting), and move items higher than it to the R and items lower to it to the L. It sorts in place and uses recursion.

Git Branching

1.  Give an instance when you would use git branching.
    When you want to work on a new feature without introducing it to the master branch until its complete
2.  What is a pull request?
    A request to have the owner review your changes and merge/commit if it passes